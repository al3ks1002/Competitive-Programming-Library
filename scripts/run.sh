#!/bin/bash

# Tests your source code against some tests.
# The tests must be in the following format: test$x.in test$x.ok

# Color codes for colored echo.
RED='\033[0;31m'
GREEN='\033[0;32m'

# Function needed to show the usage.
usage() {
    echo "Usage -s source_file -t tests_directory [-c checker]."
    exit 1
}

# Parses the parameters.
while getopts ":s:t:c:" opt; do
    case $opt in
        s)
            # Gets the source file.
            sourcefile=$OPTARG
            ;;
        t)
            # Gets the tests directory.
            tests=$OPTARG
            ;;
        c)
            # Gets the checker file.
            checker=$OPTARG
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            usage
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            usage
            ;;
    esac
done

# Checks if the source file and tests directory are not empty.
if [[ -z $sourcefile || -z $tests ]]; then
    echo "Source file and tests directory arguments are mandatory."
    usage
    exit 1
fi

# Checks if the source file exists.
if [[ ! -e $sourcefile ]]; then
    echo "$sourcefile: Source file does not exist."
    exit 1
fi

# Checks if the test directory is valid.
if [[ ! -d $tests ]]; then
    echo "$tests: Test directory is invalid."
    exit 1
fi

# Compiles the source file.
g++ -w -std=c++14 -O2 -o sourcefile_exec $sourcefile
if (( $? != 0 )); then
    echo "$sourcefile: Compilation error."
    exit 1
fi

# Checks if the checker exists.
if [[ ! -z $checker ]]; then
    # Checks if the checker file exists.
    if [[ ! -e $checker ]]; then
        echo "$checker: Checker does not exist."
        exit 1
    fi

    # Compiles the checker file.
    g++ -w -std=c++14 -O2 -o checker_exec $checker
    if (( $? != 0 )); then
        echo "$checker: Compilation error."
        exit 1
    fi
fi

# Goes through all the tests sorted numerically.
for input in $(find $tests -name "test*.in" | sort -V); do
    # $input represents the input file.

    # $output represents the output file generated by the source file.
    touch output

    # Runtime error flag.
    runtime_error=0

    # Gets the CPU runtime in format "x.xxx".
    runtime=$( (TIMEFORMAT='%3R'; time ./sourcefile_exec < $input > output) 2>&1)

    # If the length of the runtime doesn't have 5 characters, there is a runtime error.
    if [[ "${#runtime}" != "5" ]]; then
        runtime_error=1
    fi

    # Gets the ok file.
    ok=`echo $input | rev | sed s/ni/ko/1 | rev`

    # Gets the test number.
    testnumber=`echo $input | rev | cut -d / -f 1 | sed 's/[^0-9]//g' | rev`

    # If the test number is < 10, it adds a leading 0 (helps with the indentation).
    if (( testnumber < 10 )); then
        testnumber="0$testnumber"
    fi

    # If there is a runtime error, gets the runtime error message.
    if [[ $runtime_error != 0 ]]; then
        message="${RED}Test $testnumber | 0.000 | Runtime Error"
    else
        # Checks if the checker exists.
        if [[ -z $checker ]]; then
            # If not, does a word diff between the output file and the ok file.
            dwdiff output $ok > /dev/null

            # Gets the message based on the diff.
            if [[ $? != 0 ]]; then
                message="${RED}Test $testnumber | $runtime | Wrong Answer"
            else
                message="${GREEN}Test $testnumber | $runtime | Correct"
            fi
        else
            # If yes, runs the checker.
            # The checker should print to stdout the result and exit with a code.
            # 0 - okay;
            # 1 - wrong;
            # 2 - something went bad when running the checker (probably the args were invalid).
            result=$(./checker_exec input output $ok)

            # Gets the message based on the checker exit code.
            if [[ $? == 0 ]]; then
                message="${GREEN}Test $testnumber | $runtime | $result"
            else
                message="${RED}Test $testnumber | $runtime | $result"
            fi
        fi
    fi

    # Prints the test result.
    printf "$message\n"

    # Cleans the output.
    rm output
done

# Cleans the executable files.
rm sourcefile_exec
rm checker_exec 2> /dev/null
